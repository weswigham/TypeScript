=== tests/cases/compiler/genericsWithoutTypeParameters1.ts ===
class C<T> {
>C : C<T>
>T : T

    foo(): T { return null }
>foo : () => T
>T : T
>null : null
}

interface I<T> {
>I : I<T>
>T : T

    bar(): T;
>bar : () => T
>T : T
}

var c1: C;
>c1 : C<{}>
>C : C<T>

var i1: I;
>i1 : I<{}>
>I : I<T>

var c2: C<I>;
>c2 : C<I<{}>>
>C : C<T>
>I : I<T>

var i2: I<C>;
>i2 : I<C<{}>>
>I : I<T>
>C : C<T>

function foo(x: C, y: I) { }
>foo : (x: C<{}>, y: I<{}>) => void
>x : C<{}>
>C : C<T>
>y : I<{}>
>I : I<T>

function foo2(x: C<I>, y: I<C>) { }
>foo2 : (x: C<I<{}>>, y: I<C<{}>>) => void
>x : C<I<{}>>
>C : C<T>
>I : I<T>
>y : I<C<{}>>
>I : I<T>
>C : C<T>

var x: { a: C } = { a: new C<number>() };
>x : { a: C<{}>; }
>a : C<{}>
>C : C<T>
>{ a: new C<number>() } : { a: C<number>; }
>a : C<number>
>new C<number>() : C<number>
>C : typeof C

var x2: { a: I } = { a: { bar() { return 1 } } };
>x2 : { a: I<{}>; }
>a : I<{}>
>I : I<T>
>{ a: { bar() { return 1 } } } : { a: { bar(): number; }; }
>a : { bar(): number; }
>{ bar() { return 1 } } : { bar(): number; }
>bar : () => number
>1 : 1

class D<T> {
>D : D<T>
>T : T

    x: C;
>x : C<{}>
>C : C<T>

    y: D;
>y : D<{}>
>D : D<T>
}

interface J<T> {
>J : J<T>
>T : T

    x: I;
>x : I<{}>
>I : I<T>

    y: J;
>y : J<{}>
>J : J<T>
}

class A<T> { }
>A : A<T>
>T : T

function f<T>(x: T): A {
>f : <T>(x: T) => A<{}>
>T : T
>x : T
>T : T
>A : A<T>

    return null;
>null : null
}
